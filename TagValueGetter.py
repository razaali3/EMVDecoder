{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [],
   "source": [
    "from selenium import webdriver\n",
    "from selenium.webdriver.support.ui import Select\n",
    "\n",
    "def show_insurance( TLVString ):\n",
    "    path_to_chromedriver = \"C:\\\\chromedriver_win32\\\\chromedriver.exe\" # change path as needed\n",
    "    browser = webdriver.Chrome(executable_path = path_to_chromedriver)\n",
    "    url = \"http://www.tvr-decoder.appspot.com/t/home\"\n",
    "    browser.get(url)\n",
    "    \n",
    "    select = Select( browser.find_element_by_id('tag_field') )\n",
    "    select.select_by_value('constructed')\n",
    "    \n",
    "    browser.find_element_by_id('value_field').send_keys( TLVString ) # xpath of the text box to send text\n",
    "    browser.find_element_by_xpath(\"//input[@value='Decode'][@type='submit']\").click() # xpath of the enter or submit button to click\n",
    "    \n",
    "    return browser.current_url\n",
    "\n",
    "def hello_world():\n",
    "    TLV = '95050480008000'\n",
    "    url = show_insurance(TLV)\n",
    "    return url\n",
    "\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    hello_world()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "[('800000', 'Manual key entry'), ('400000', 'Magnetic stripe'), ('200000', 'IC with contacts'), ('008000', 'Plaintext PIN for ICC verification'), ('004000', 'Enciphered PIN for online verification'), ('002000', 'Signature (paper)'), ('001000', 'Enciphered PIN for offline verification'), ('000080', 'SDA'), ('000040', 'DDA')]\n",
      "9F33\n",
      "E0F0C0\n",
      "Terminal Capabilities\n",
      "57 contains masked data XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n"
     ]
    }
   ],
   "source": [
    "import re\n",
    "        \n",
    "class Tag():\n",
    "    def __init__(self, acronym, name, field_length, bit_list):\n",
    "        self.acronym = acronym\n",
    "        self.name = name\n",
    "        self.field_length = field_length\n",
    "        self.bit_list = bit_list\n",
    "\n",
    "tags = {\n",
    "    '95': Tag('TVR', 'Terminal Verification Results', 10, (\n",
    "    (0x8000000000, 'Offline data authentication was not performed'),\n",
    "    (0x4000000000, 'SDA failed'),\n",
    "    (0x2000000000, 'ICC data missing'),\n",
    "    (0x1000000000, 'Card appears on terminal exception file'),\n",
    "    (0x0800000000, 'DDA failed'),\n",
    "    (0x0400000000, 'CDA failed'),\n",
    "    (0x0080000000, 'ICC and terminal have different application versions'),\n",
    "    (0x0040000000, 'Expired application'),\n",
    "    (0x0020000000, 'Application not yet effective'),\n",
    "    (0x0010000000, 'Requested service not allowed for card product'),\n",
    "    (0x0008000000, 'New card'),\n",
    "    (0x0000800000, 'Cardholder verification was not successful'),\n",
    "    (0x0000400000, 'Unrecognised CVM'),\n",
    "    (0x0000200000, 'PIN try limit exceeded'),\n",
    "    (0x0000100000, 'PIN entry required and PIN pad not present or not working'),\n",
    "    (0x0000080000, 'PIN entry required, PIN pad present, but PIN was not entered'),\n",
    "    (0x0000040000, 'Online PIN entered'),\n",
    "    (0x0000008000, 'Transaction exceeds floor limit'),\n",
    "    (0x0000004000, 'Lower consecutive offline limit exceeded'),\n",
    "    (0x0000002000, 'Upper consecutive offline limit exceeded'),\n",
    "    (0x0000001000, 'Transaction selected randomly for online processing'),\n",
    "    (0x0000000800, 'Merchant forced transaction online'),\n",
    "    (0x0000000080, 'Default TDOL used'),\n",
    "    (0x0000000040, 'Issuer authentication failed'),\n",
    "    (0x0000000020, 'Script processing failed before final GENERATE AC'),\n",
    "    (0x0000000010, 'Script processing failed after final GENERATE AC'),\n",
    "    )),\n",
    "    '9B': Tag('TSI', 'Terminal Status Indicator', 4, (\n",
    "    (0x8000, 'Offline data authentication was performed'),\n",
    "    (0x4000, 'Cardholder verification was performed'),\n",
    "    (0x2000, 'Card risk management was performed'),\n",
    "    (0x1000, 'Issuer authentication was performed'),\n",
    "    (0x0800, 'Terminal risk management was performed'),\n",
    "    (0x0400, 'Script processing was performed'),\n",
    "    )),\n",
    "    '82': Tag('AIP', 'Application Interchange Profile', 4, (\n",
    "    (0x4000, 'SDA supported'),\n",
    "    (0x2000, 'DDA supported'),\n",
    "    (0x1000, 'Cardholder verification is supported'),\n",
    "    (0x0800, 'Terminal risk management is to be performed'),\n",
    "    (0x0400, 'Issuer authentication is supported'),\n",
    "    (0x0100, 'CDA supported'),\n",
    "    )),\n",
    "    '9F33' : Tag('TC', 'Terminal Capabilities', 6, (\n",
    "    (0x800000, 'Manual key entry'),\n",
    "    (0x400000, 'Magnetic stripe'),\n",
    "    (0x200000, 'IC with contacts'),\n",
    "    (0x008000, 'Plaintext PIN for ICC verification'),\n",
    "    (0x004000, 'Enciphered PIN for online verification'),\n",
    "    (0x002000, 'Signature (paper)'),\n",
    "    (0x001000, 'Enciphered PIN for offline verification'),\n",
    "    (0x000800, 'No CVM Required'),\n",
    "    (0x000080, 'SDA'),\n",
    "    (0x000040, 'DDA'),\n",
    "    (0x000020, 'Card capture'),\n",
    "    (0x000008, 'CDA')\n",
    "    ))\n",
    "}\n",
    "\n",
    "class SimpleTag():\n",
    "    def __init__(self, name, field_length):\n",
    "        self.name = name\n",
    "        self.field_length = field_length\n",
    "    \n",
    "simpleTags = {\n",
    "    '57' : SimpleTag('Track 2 Equivalent Data', 38)\n",
    "}\n",
    "\n",
    "def decodeSimpleTags( tag, value ):\n",
    "    errors = isSimpleValidValue( tag, value )\n",
    "    if len(errors) != 0:\n",
    "        print(errors)\n",
    "        return\n",
    "    \n",
    "    if tag not in simpleTags:\n",
    "        print('%s tag is not valid or not supported' % tag)\n",
    "        return\n",
    "    \n",
    "    print(tag)\n",
    "    print(value)\n",
    "    print(tag_data.name)\n",
    "    \n",
    "    \n",
    "def isSimpleValidValue(tag, value):\n",
    "    tag_data = simpleTags[tag]\n",
    "    if tag_data != None and len(value) > tag_data.field_length:\n",
    "        return '%s must be within %d characters' % (tag, tag_data.field_length)\n",
    "    if not re.match('^[0-9a-fA-F]+$', value):\n",
    "        if re.match('^[X]+$', value):\n",
    "            return '%s contains masked data %s' % (tag, value)\n",
    "        return '%s must contain only hexadecimal characters. ie 0-9 and A-F.' % tag\n",
    "    return ()\n",
    "    \n",
    "def decode( tag, value ):\n",
    "    tag = tag.upper()\n",
    "    \n",
    "    if tag not in tags:\n",
    "        decodeSimpleTags( tag, value )\n",
    "        return\n",
    "    \n",
    "    errors = isValidValue(tag, value)\n",
    "    if len(errors) != 0:\n",
    "        print(errors)\n",
    "        return\n",
    "    \n",
    "    tag_data = tags[tag]\n",
    "    set_bits = []\n",
    "    int_value = int(value, 16)\n",
    "    for bit in tag_data.bit_list:\n",
    "        if int_value & bit[0] == bit[0]:\n",
    "            set_bits.append((('%0' + str(tag_data.field_length) + 'X') % bit[0], bit[1]))\n",
    "    print(set_bits)\n",
    "    print(tag)\n",
    "    print(value)\n",
    "    print(tag_data.name)\n",
    "    return\n",
    "    \n",
    "    \n",
    "def isValidValue(tag, value):\n",
    "    tag_data = tags[tag]\n",
    "    if tag_data != None and len(value) != tag_data.field_length:\n",
    "        return '%s must be %d exactly characters long' % (tag, tag_data.field_length)\n",
    "    if not re.match('^[0-9a-fA-F]+$', value):\n",
    "        return '%s must contain only hexadecimal characters. ie 0-9 and A-F.' % tag\n",
    "    return ()\n",
    "\n",
    "def main():\n",
    "    decode( '9F33', 'E0F0C0' )\n",
    "    decode('57', 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Requirement already satisfied: django in c:\\programdata\\anaconda3\\lib\\site-packages (3.0.8)\n",
      "Requirement already satisfied: sqlparse>=0.2.2 in c:\\programdata\\anaconda3\\lib\\site-packages (from django) (0.3.1)\n",
      "Requirement already satisfied: asgiref~=3.2 in c:\\programdata\\anaconda3\\lib\\site-packages (from django) (3.2.10)\n",
      "Requirement already satisfied: pytz in c:\\programdata\\anaconda3\\lib\\site-packages (from django) (2019.1)\n",
      "Note: you may need to restart the kernel to use updated packages.\n"
     ]
    }
   ],
   "source": [
    "pip install django"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
